# statistical analysis reweighting


```{r ,include=FALSE}
library(Rose)
library(ggplot2)
library(plotly)
library(knitr)


df <- data.frame(x = 1:5, y = 1:5)
f1 <- function(df) {
  gg <- ggplot(df, aes(x, y)) +
    geom_point()
  assign("ggp", plotly::ggplotly(gg), envir = parent.frame())
  # ggp
  df # NOT returning a plot
}
res1 <- f1(df)
ggp # Let knit handle the plot
myplotly(ggplot())
```

to reweigh an observable we have to compute

$$
\frac{\int dU e^{-S[U]} O(U) r(U)}{\int dU e^{-S[U]}r(U)}= \frac{\int dU e^{-S[U]} O(U) r(U)}{\int dU e^{-S[U]}r(U)} \frac{\int dU e^{-S[U]}}{\int dU e^{-S[U]}} = 
\frac{\langle Or \rangle}{\langle r\rangle}\,.
$$
$r$ is computed stochastically as 
$$
r(U)= \langle r(U) \rangle_\phi= \det\left(D(\mu_f)/D(\mu_i)\right) = \int d\phi e^{w(U,\phi)}
$$
with $w(U,\phi)=\phi^\dagger(1-D(\mu_i) D^{-1}(\mu_f))\phi$ and $\phi$ a gaussian noise $P(\phi)\propto e^{-\phi^2}$.

Since $\det\left(D(\mu_f)/D(\mu_i)\right)$ may be complex we compute
$$
\left| \det\left(D(\mu_f)/D(\mu_i)\right)\right|=\sqrt{\det\left(D^{-1}(\mu_i)D(\mu_f)D(-\mu_f)D^{-1}(-\mu_i)\right)}\\
=\left(\int d\phi e^{\phi^\dagger(1-D(-\mu_i)D^{-1}(-\mu_f)D^{-1}(\mu_f)D(\mu_i))\phi}\right)^{\frac{1}{2}}
$$ 
, thus the observable to compute is 

$$
\frac{\langle O \langle r\rangle_\phi \rangle_U}{\langle \langle r\rangle_\phi\rangle_{U}}\,.
$$

1. Ignoring the error on $r$ we can define 

   $$
  \bar r(U_i)=\frac{\sum_j r(U_i,\phi_{ij})}{\frac{1}{N_U}\sum_{i_1,j}    r(U_{i_1},\phi_{ij})}
   $$
   we can compute the sum in the numerator and in the denominator as in (@eq-wu) and (@eq-wu-OS)
   then we can binning the data to  take into account for autocorrelation
   $$
\tilde O_b=\frac{1}{N_b}\sum_{i=bN_b}^{bN_b+N_b} O(U_i)   \bar{r}(U_i)
   $$
   and then the jackknifes as
   $$
Jack(O)_j=\frac{1}{N-1}\sum_{a\neq j} \tilde O_a
   $$
2. to fully propagate the error instead we have to 
   first  to bin the data to take into account for autocorrelation
   $$
{ [Or]}_b=\frac{1}{N_b}\sum_{i=bN_b}^{bN_b+N_b} O(U_i)    \frac{1}{N_j}\sum_jr(U_i,\phi_{ij})\\
[r]_b=\frac{1}{N_b}\sum_{i=bN_b}^{bN_b+N_b} \frac{1}{N_j}\sum_jr(U_i,\phi_{ij})
   $$
   we can not compute $r(U_i,\phi_{ij})$ with double precision, but we can compute
   the exponent of it and the exponent of a sum
   $$
w(U_i)=\log \left(\frac{1}{N_j}\sum_j r(U_i,\phi_{ij})\right)= w(U_i,\phi_{i0})+\log\left(\frac{1}{N_j}\sum_j e^{w(U_i,\phi_{ij})- w(U_i,\phi_{i0})}\right)\,.\\
   $$ {#eq-wu}
   For the case of an OS reweighting we need to take into account the square     root factor as
   $$
w(U_i)=\frac{1}{2}\log \left(\frac{1}{N_j}\sum_j r(U_i,\phi_{ij})\right)= \frac{1}{2}w(U_i,\phi_{i0})+\frac{1}{2}\log\left(\frac{1}{N_j}\sum_j e^{w(U_i,\phi_{ij})- w(U_i,\phi_{i0})}\right)\,.\\
   $$ {#eq-wu-OS}
   Then we compute the exponent of the binning.
   $P_b= \log([Or]_b)$ and $w_b=\log([r]_b)$
   $$
P_b=w(U_{bN_b}) +\log\left(\frac{1}{N_b}\sum_{i=bN_b}^{bN_b+N_b}O(U_i) e^{w(U_i)- w(U_{bN_b})}\right)\\
w_b=w(U_{bN_b}) +\log\left(\frac{1}{N_b}\sum_{i=bN_b}^{bN_b+N_b} e^{w(U_i)- w(U_{bN_b})}\right)
   $$
   After we can compute the jackknifes of the ratio
   $$
\frac{Jack(Or)_j}{Jack(r)_j}=\frac{\sum_{a\neq j} [O]_a  }{\sum_{b\neq j} [r]_b}=\frac{\sum_{a\neq j} e^{P_a}  }{\sum_{b\neq j} e^{w_{b}}}=\sum_{a\neq j}\frac{ 1  }{\sum_{b\neq j} e^{w_{b}-P_a}}
   $$

## comparison


```{r, results='asis',echo=FALSE}
df <- NULL

######################## rew
mt <- read_df("/home/garofalo/analysis/flow/data/out/flow_B64.dat_reweight_charm_OS_B64.dat_output")
all_obs <- Rose::get_all_corr(mt)
df <- add_corr_to_df("W_rewcOS_only_mean(t)", all_obs, mt, df, print_res = FALSE, nudge = 0.0, rename ="W(t) method 1",reshape = FALSE)
df <- add_corr_to_df("W_rewcOS(t)", all_obs, mt, df, print_res = FALSE,
                     nudge = 0.3, rename = "W(t) method 2",reshape = FALSE)

######################## rew
df <- df[seq(1, length(df$x), by = 3)   , ]

#########################
# l<-which(df$xfit==150 & df$label=="W(t)")
# save_res<-df[l,]
# print_full_res("w0+all_mu_correction", all_obs, mt)

# df$x <- 0.010000 + df$x * 0.02
# df$xfit <- 0.010000 + df$xfit * 0.02
# df$tmin <- 0.010000 + df$tmin * 0.02
# df$tmax <- 0.010000 + df$tmax * 0.02

gg <- plot_df_corr_ggplot(df, width = 0.05)
# gg<-myggplot()
gg <- gg + geom_hline(yintercept = 0.3)

fig <- myplotly(gg, "", "$t/a^2$", "$W(t)$", to_print = TRUE)
```